!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Worley=e()}(this,function(){"use strict";class s{constructor(t=s["default"]()){for(t=Object.assign(s["default"](),t),this.width=t.width,this.height=t.height,this.crests=[],this.threshold=t.threshold,this.threshold==undefined&&(this.threshold=s.predictThreshold(t.width,t.height,t.crests)),s.generateCrests(t,this),this.hierachy=t.hierachy,this.metric=t.metric,this.interpolate=t.interpolate,this.interpolant=t.interpolant,this.colors=t.colors,this.alpha=!!t.alpha&&t.alpha+1e-5;t.seed.length<4;)t.seed.push(Math.floor(10*Math.random()*(2456665234*Math.random())));this.Texture={parent:this,async generate(){const a=new Uint8ClampedArray(this.parent.width*this.parent.height),t=this.parent.width,r=this.parent.height;for(let e=0;e<=t;e++)for(let t=0;t<=r;t++)a[t*this.parent.width+e]=await this.parent.pixel(e,t);return this.data=a,a},data:null,async ImageData(e=this.parent.colors,a=this.parent.alpha,t=!1){this.data&&!t||await this.generate();let r;r="undefined"==typeof window||"function"!=typeof window.ImageData?{[Symbol.toStringTag]:"ImageData",width:this.parent.width,height:this.parent.height,data:new Uint8ClampedArray(this.parent.width*this.parent.height*4)}:new ImageData(this.parent.width,this.parent.height);for(let t=0;t<r.data.length;t++){var h=this.data[Math.floor(t/4)]/255;if((t+1)%4!=0)if(e)switch((t+1)%4){case 1:var i=e[0][0],s=e[1][0];r.data[t]=i+(s-i)*h;break;case 2:var n=e[0][1],d=e[1][1];r.data[t]=n+(d-n)*h;break;case 3:d=e[0][2],n=e[1][2];r.data[t]=d+(n-d)*h}else r.data[t]=this.data[Math.floor(t/4)];else r.data[t]=255-255*h*Number(a)}return r}}}addCrest(t,e,a=!1){if(t==undefined||e==undefined)throw new Error("Cannot add crest without given coordiantres.");this.crests.push(a?[Math.round(t*this.width),Math.round(e*this.height)]:[t,e])}async nearestCrest(e=0,a=0,t=0){if(0===this.crests.length)return[Infinity,Infinity];const r=this.crests.slice(0),h=r.length;for(let t=0;t<h;t++){var i=r[t];r[t]={crest:i,distance:s.magnitude([e-i[0],a-i[1]])}}return s.find(r,t).crest}async pixel(t,e,a=this.interpolate,r=this.hierachy){r=await this.nearestCrest(++t,e,r),r=s.magnitude([t-r[0],e-r[1]],this.metric);return a?this.interpolant(0,255,s.clamp(r/this.threshold,0,1)):255*s.clamp(r/this.threshold,0,1)}static clamp(t,e,a){return a<t?a:t<e?e:t}static interpolate(t,e,a=.5){return t+(e-t)*(a=(Math.sin(Math.PI*a-Math.PI/2)+1)/2)}static generateCrests(t=s["default"](),e){const a=s.rand(t.seed[0],t.seed[1],t.seed[2],t.seed[3]),r=t.prerun,h=t.crests;for(let t=0;t<=r;t++)a();for(let t=0;t<h;t++)e.addCrest(a(),a(),!0)}static magnitude(t,e={type:"minkowski",p:2}){switch(e.type){case"euclidean":return Math.sqrt(t[0]**2+t[1]**2);case"manhattan":return Math.abs(t[0])+Math.abs(t[1]);case"minkowski":return Math.pow(t[0]**e.p+t[1]**e.p,1/e.p);default:return Math.sqrt(t[0]**2+t[1]**2)}}static predictThreshold(t,e,a){return Math.sqrt(t*e/(4*a))}static"default"(){return{width:100,height:100,crests:20,hierachy:0,interpolate:!0,interpolant:s.interpolate,colors:!1,alpha:!1,seed:[10*Math.floor(Math.random()*(2456665234*Math.random())),10*Math.floor(Math.random()*(6242145234*Math.random())),10*Math.floor(Math.random()*(9253524321*Math.random())),10*Math.floor(Math.random()*(4364645634*Math.random()))],prerun:5,metric:{type:"euclidean"}}}static rand(e,a,r,h){return function(){var t=((e|=0)+(a|=0)|0)+(h|=0)|0;return h=h+1|0,e=a^a>>>9,a=(r|=0)+(r<<3)|0,r=(r=r<<21|r>>>11)+t|0,(t>>>0)/4294967296}}static find(e,a){++a>e.length&&(a=e.length);for(let t=0;t<a;t++)for(let t=0;t<e.length-1;t++)e[t].distance<e[t+1].distance&&([e[t],e[t+1]]=[e[t+1],e[t]]);return e[e.length-a]}}return s});
