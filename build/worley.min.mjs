class Worley{constructor(t=Worley.default()){for(t=Object.assign(Worley.default(),t),this.width=t.width,this.height=t.height,this.crests=Worley.generateCrests(t),this.threshold=t.threshold,null==this.threshold&&(this.threshold=Worley.predictThreshold(t.width,t.height,t.crests)),this.hierachy=t.hierachy,this.metric=t.metric,this.interpolate=t.interpolate,this.interpolant=t.interpolant,this.colors=t.colors,this.alpha=!!t.alpha&&t.alpha+1e-5;t.seed.length<4;)t.seed.push(Math.floor(10*Math.random()*(2456665234*Math.random())));this.seed=t.seed.sort(),this.Texture={parent:this,async generate(){let t=new Uint8ClampedArray(this.parent.width*this.parent.height);for(let e=0;e<=this.parent.width;e++)for(let a=0;a<=this.parent.height;a++)t[a*this.parent.width+e]=await this.parent.pixel(e,a);return this.data=t,t},data:null,async ImageData(t=this.parent.colors,e=this.parent.alpha,a=!1){let r;this.data&&!a||await this.generate(),r="undefined"==typeof window||"function"!=typeof window.ImageData?{[Symbol.toStringTag]:"ImageData",width:this.parent.width,height:this.parent.height,data:new Uint8ClampedArray(this.parent.width*this.parent.height*4)}:new ImageData(this.parent.width,this.parent.height);for(let a=0;a<r.data.length;a++){let h=this.data[Math.floor(a/4)]/255;if((a+1)%4!=0)if(t)switch((a+1)%4){case 1:let e=t[0][0],s=t[1][0];r.data[a]=e+(s-e)*h;break;case 2:let i=t[0][1],n=t[1][1];r.data[a]=i+(n-i)*h;break;case 3:let o=t[0][2],l=t[1][2];r.data[a]=o+(l-o)*h}else r.data[a]=this.data[Math.floor(a/4)];else r.data[a]=255-255*h*Number(e)}return r}}}addCrest(t,e,a){if(null==t||null==e)throw new Error("Cannot add crest without given coordiantres.");a?this.crests.push([Math.round(t*this.width),Math.round(e*this.height)]):this.crests.push([t,e])}async nearestCrest(t=0,e=0,a=0){if(0===this.crests.length)return[1/0,1/0];let r=this.crests.slice(0);for(let a=0;a<r.length;a++){let h=r[a];r[a]={crest:h,distance:Worley.magnitude([t-h[0],e-h[1]])}}return r.sort((t,e)=>t.distance-e.distance)[a].crest}async pixel(t,e,a=this.interpolate,r=this.hierachy){let h=await this.nearestCrest(t,e,r),s=Worley.magnitude([t-h[0],e-h[1]],this.metric);return a?this.interpolant(0,255,Worley.clamp(s/this.threshold,0,1)):255*Worley.clamp(s/this.threshold,0,1)}static clamp(t,e,a){return t>a?a:e>t?e:t}static interpolate(t,e,a=.5){return t+(e-t)*(a=(Math.sin(Math.PI*a-Math.PI/2)+1)/2)}static generateCrests(t=Worley.default()){let e=Worley.rand(t.seed[0],t.seed[1],t.seed[2],t.seed[3]);for(let a=0;a<=t.prerun;a++)e();return Array.from({length:t.crests},()=>[Math.round(e()*t.width),Math.round(e()*t.height)])}static magnitude(t,e={type:"minkowski",p:2}){switch(e.type){case"euclidean":return Math.sqrt(t[0]**2+t[1]**2);case"manhattan":return Math.abs(t[0])+Math.abs(t[1]);case"minkowski":return Math.pow(t[0]**e.p+t[1]**e.p,1/e.p);default:return Math.sqrt(t[0]**2+t[1]**2)}}static predictThreshold(t,e,a){return Math.sqrt(t*e/(4*a))}static default(){return{width:100,height:100,crests:20,hierachy:0,interpolate:!0,interpolant:Worley.interpolate,colors:!1,alpha:!1,seed:[10*Math.floor(Math.random()*(2456665234*Math.random())),10*Math.floor(Math.random()*(6242145234*Math.random())),10*Math.floor(Math.random()*(9253524321*Math.random())),10*Math.floor(Math.random()*(4364645634*Math.random()))],prerun:5,metric:{type:"euclidean"}}}static rand(t,e,a,r){return function(){var h=((t|=0)+(e|=0)|0)+(r|=0)|0;return r=r+1|0,t=e^e>>>9,e=(a|=0)+(a<<3)|0,a=(a=a<<21|a>>>11)+h|0,(h>>>0)/4294967296}}}export default Worley;